/**
 * CVE-2018-1000810
 * How to reproduce this bug:
 *     - This bug need to be reproduced in release build.
 *     - cargo run --release
 */
extern crate core;
use core::ptr;

unsafe fn repeat<T: Copy>(a: &[T], n: usize){
    let mut buf: Vec<T> = Vec::with_capacity(a.len() * n);
    // let mut buf = Vec::with_capacity(a.len().checked_mul(n).expect("capacity overflow"));
    buf.extend_from_slice(a);  
    let mut m = n >> 1;
    while m > 0 {
        ptr::copy_nonoverlapping(
            buf.as_ptr(),
            (buf.as_mut_ptr() as *mut T).add(buf.len()),
            buf.len(),
        );

        let buf_len = buf.len();
        buf.set_len(buf_len * 2);

        m >>= 1;
    }
    let rem_len = a.len() * n - buf.len();
    if rem_len > 0 {
        ptr::copy_nonoverlapping(
            buf.as_ptr(),
            (buf.as_mut_ptr() as *mut T).add(buf.len()),
            rem_len,
        );
        let buf_cap = buf.capacity();
        buf.set_len(buf_cap);
    }
    println!("{} {}", buf.len(), buf.capacity());
}

fn main() {
    let a: &[u8; 16] = b"0123456789abcdef";
    let n: usize = 1 << 63;
    unsafe {
        repeat(a, n);
    }
}
